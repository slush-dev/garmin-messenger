package contacts

import (
	"fmt"
	"os"
	"path/filepath"

	"gopkg.in/yaml.v3"
)

const (
	contactsFile = "contacts.yaml"
	stateFile    = "state.yaml"
)

// Contacts is the in-memory representation of contacts.yaml.
type Contacts struct {
	Members       map[string]string `yaml:"members"`
	Conversations map[string]string `yaml:"conversations"`
}

// ResolveMember returns the friendly name for memberID, or empty string.
func (c *Contacts) ResolveMember(memberID string) string {
	if c == nil || c.Members == nil {
		return ""
	}
	return c.Members[memberID]
}

// ResolveConversation returns the friendly name for convID, or empty string.
func (c *Contacts) ResolveConversation(convID string) string {
	if c == nil || c.Conversations == nil {
		return ""
	}
	return c.Conversations[convID]
}

// LoadContacts reads contacts.yaml from sessionDir.
func LoadContacts(dir string) *Contacts {
	path := filepath.Join(dir, contactsFile)
	data, err := os.ReadFile(path)
	if err != nil {
		return &Contacts{
			Members:       make(map[string]string),
			Conversations: make(map[string]string),
		}
	}
	var c Contacts
	if err := yaml.Unmarshal(data, &c); err != nil {
		return &Contacts{
			Members:       make(map[string]string),
			Conversations: make(map[string]string),
		}
	}
	if c.Members == nil {
		c.Members = make(map[string]string)
	}
	if c.Conversations == nil {
		c.Conversations = make(map[string]string)
	}
	return &c
}

// SaveContacts writes contacts.yaml to sessionDir.
func SaveContacts(dir string, c *Contacts) error {
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return err
	}
	path := filepath.Join(dir, contactsFile)
	data, err := yaml.Marshal(c)
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0o644)
}

// MergeMembers merges API member data into existing members.
// New keys are added; existing empty names are updated; non-empty names preserved.
func MergeMembers(existing map[string]string, apiMembers []struct{ Key, Name string }) map[string]string {
	result := make(map[string]string, len(existing))
	for k, v := range existing {
		result[k] = v
	}
	for _, m := range apiMembers {
		if _, exists := result[m.Key]; !exists || result[m.Key] == "" {
			result[m.Key] = m.Name
		}
	}
	return result
}

// MergeConversations adds new conversation IDs with empty names.
func MergeConversations(existing map[string]string, convIDs []string) map[string]string {
	result := make(map[string]string, len(existing))
	for k, v := range existing {
		result[k] = v
	}
	for _, cid := range convIDs {
		if _, exists := result[cid]; !exists {
			result[cid] = ""
		}
	}
	return result
}

// LoadAddresses reads UUID→phone mapping from state.yaml.
func LoadAddresses(dir string) map[string]string {
	path := filepath.Join(dir, stateFile)
	data, err := os.ReadFile(path)
	if err != nil {
		return make(map[string]string)
	}
	var state struct {
		Addresses map[string]string `yaml:"addresses"`
	}
	if err := yaml.Unmarshal(data, &state); err != nil {
		return make(map[string]string)
	}
	if state.Addresses == nil {
		return make(map[string]string)
	}
	return state.Addresses
}

// SaveAddresses writes UUID→phone mapping to state.yaml.
func SaveAddresses(dir string, addresses map[string]string) error {
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return err
	}
	path := filepath.Join(dir, stateFile)
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintln(f, "# DO NOT EDIT — auto-generated by garmin-messenger")
	state := struct {
		Addresses map[string]string `yaml:"addresses"`
	}{Addresses: addresses}
	enc := yaml.NewEncoder(f)
	enc.SetIndent(2)
	return enc.Encode(state)
}

// MergeAddresses merges API addresses. Always overwrites with latest server value.
func MergeAddresses(existing map[string]string, apiAddresses []struct{ UUID, Phone string }) map[string]string {
	result := make(map[string]string, len(existing))
	for k, v := range existing {
		result[k] = v
	}
	for _, a := range apiAddresses {
		if a.Phone != "" {
			result[a.UUID] = a.Phone
		}
	}
	return result
}
